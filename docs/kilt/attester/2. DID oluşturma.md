# DID (Merkeziyetsiz TanÄ±mlayÄ±cÄ±lar) ğŸŒ

ArtÄ±k bir Ã¶nceki aÃ§Ä±klamada oluÅŸturduÄŸumuz hesap ile `Attester` iÃ§in DID oluÅŸturmaya baÅŸlayabiliriz. ğŸš€

DID'ler bir bireyi, organizasyonu veya makineyi ifade edebilir. ğŸ§‘â€ğŸ¤â€ğŸ§‘ğŸ¢ğŸ¤–

:::caution DID'ler Nedir? ğŸ¤”
- Mevcut sistemimizde, dijital kimliÄŸimiz iÃ§in merkezi bir otoriteye (Ã¶rneÄŸin devlet ğŸ‘®â€â™‚ï¸) veya tekelleÅŸmiÅŸ hizmetlere (Google, Facebook vb. ğŸ¢) gÃ¼venmek zorundayÄ±z.
- DID, Merkezsiz TanÄ±mlayÄ±cÄ± anlamÄ±na gelir. DIDs ile kendi dijital geminizin kaptanÄ± olabilirsiniz! âš“ï¸ğŸ”—
- GizliliÄŸi ve gÃ¼venliÄŸi artÄ±rÄ±r. ğŸ•µï¸â€â™‚ï¸ğŸ”’
:::

KILT DID'leri her kullanÄ±cÄ±ya Ã¶zel olarak atanan Ã¶zgÃ¼n kimliklerdir. ğŸ†” DID'lerinizi KILT zinciri iÃ§erisinde depolayabilirsiniz. ğŸ—ƒï¸

:::info KILT DID Åifreleme DesteÄŸi ğŸ”
- `Authentication Keypair` ğŸ›¡ï¸
- `Key-agreement Keypair` ğŸ¤
- `Assertion-method Keypair` âœ…
- `Capability-delegation Keypair` ğŸ“
:::

## Account vs DID ğŸ¤·â€â™‚ï¸

DID'ler zincir Ã¼zerinde kayÄ±t edilmek zorundadÄ±r. ğŸ“ Her zaman bu iÅŸlemi gerÃ§ekleÅŸtirip deposito Ã¶deyen ve bu sayede DID'i onaylama iÅŸlemine sokan bir hesap bulunmaktadÄ±r. ğŸ’°

## DID OluÅŸturma ğŸ› ï¸

DID oluÅŸturmak iÃ§in daha Ã¶ncesinde hesap oluÅŸturmak iÃ§in kullandÄ±ÄŸÄ±mÄ±z `keyring` deÄŸerlerini yeniden kullanabiliriz. ğŸ”„ `Attester` oluÅŸturmak iÃ§in 4 adet anahtara ihtiyaÃ§ duymaktayÄ±z. ğŸ”‘

---
### Anahtar Ã‡iftleri OluÅŸturma

#### ModÃ¼llerin Ä°Ã§e AktarÄ±lmasÄ±

```typescript title="attester/generateKeypairs.ts"
import * as Kilt from '@kiltprotocol/sdk-js'
import {
  blake2AsU8a,
  keyExtractPath,
  keyFromPath,
  mnemonicGenerate,
  mnemonicToMiniSecret,
  sr25519PairFromSeed
} from '@polkadot/util-crypto'
import { generateAccount } from './generateAccount'
```

DiÄŸer kodlarda da baÅŸladÄ±ÄŸÄ±mÄ±z Ã¼zere ilk olarak paketlerin proje iÃ§erisine eklenmesi ile baÅŸlÄ±yoruz. Paketlerimize teker teker bakacak olursak:

- Ä°lk olarak KILT SDK fonskiyonlarÄ±na eriÅŸmek iÃ§in `sdk-js` paketini kodumuzun iÃ§erisine ekleriz.
- SonrasÄ±nda `keypair` Ã§iftlerini oluÅŸturmak iÃ§in `polkadot` kÃ¼tÃ¼phanesi iÃ§erisinden birkaÃ§ methoda eriÅŸiriz.
- Son olarak bir Ã¶nceki sayfada yazdÄ±ÄŸÄ±mÄ±z hesap oluÅŸturma kodunun iÃ§erisinden export ettiÄŸimiz `generateAccount` methoduna eriÅŸiriz.

#### `generateKeyAgreement` Fonksiyonu

```typescript title="attester/generateKeypairs.ts"
function generateKeyAgreement(mnemonic: string) {
  const secretKeyPair = sr25519PairFromSeed(mnemonicToMiniSecret(mnemonic))
  const { path } = keyExtractPath('//did//keyAgreement//0')
  const { secretKey } = keyFromPath(secretKeyPair, path, 'sr25519')
  return Kilt.Utils.Crypto.makeEncryptionKeypairFromSeed(blake2AsU8a(secretKey))
}
```

Paketlerimizi yÃ¼kledikten sonra bu paketleri kullanarak anahtar Ã§iftlerimizi oluÅŸturmaya baÅŸlayabiliriz. 

Bu iÅŸlemi gerÃ§ekleÅŸtirmek iÃ§in bir fonksiyon yazarak iÅŸe baÅŸlayabiliriz. Bu fonskiyon iÃ§erisine `mnemonic` adÄ± altÄ±nda mnemonic hesap anahtarÄ±mÄ±zÄ± alacaktÄ±r. Ä°Ã§erisindeki iÅŸlemlere teker teker bakÄ±lacak olunursa:

- __`secretKeyPair`:__ Mnemonic anahtarÄ± fonksiyon iÃ§erisine girdik ancak bu anahtarÄ± kullanarak hem public hemde private anahtarlarÄ± elde etmemiz gerekmekte. Bu iÅŸlemi gerÃ§ekleÅŸtirmek iÃ§in ilk olarak `mnemonic` anahtarÄ±mÄ±zÄ± `mnemonicToMiniSecret()` fonksiyonu iÃ§erisine gireriz. Bu fonksiyon anahtarÄ±mÄ±zdan mini bir anahtar daha elde etmemizi saÄŸlar. Yeni oluÅŸan bu anahtar `sr25519PairFromSeed()` fonksiyonu ile istediÄŸimiz `secret` ve `public` anahtar Ã§ifti yapÄ±sÄ± haline gelir.
- __`path`:__ Anahtar Ã§iftimizi oluÅŸturdurduktan sonra bir sonraki iÅŸlemde `secretKey`'in oluÅŸturulabilmesi iÃ§in bu anahtarÄ±n hangi konumda saklanacaÄŸÄ± belirler.  AynÄ± zamanda bu iÅŸlem anahtarÄ±n hangi amaÃ§la kullanÄ±lacaÄŸÄ±nÄ± da ifade eder. Kodumuz iÃ§erisinde `//did//keyAgreement//0` yapÄ±sÄ± ile anahtarÄ±n bir `key agreement` olarak kullanÄ±lacaÄŸÄ± belirtilmiÅŸtir.
- `secretKey`: Bu iÅŸlem daha Ã¶ncesinde tanÄ±ttÄ±ÄŸÄ±mÄ±z iki deÄŸiÅŸkeni ve cÃ¼zdan tipini alarak -ki bizim iÃ§in bu deÄŸer ÅŸimdilik `sr25519` bir gizli anahtar oluÅŸturmaktadÄ±r. Bu iÅŸlemi `keyFromPath` methodu ile hayata geÃ§irmektedir.
- `makeEncryptionKeypairFromSeed`: Son olarak anahtar Ã§iftlerini Ã§Ä±ktÄ± vermek kalÄ±yor. Bu iÅŸlemi de KILT SDK iÃ§erisinde `Utils.Crypto.makeEncryptionKeypairFromSeed()` methodu ile return ederiz ve fonksiyon tamamlanmÄ±ÅŸ olur.


:::tip Neden Bu Kodu YazdÄ±k?
1. **GÃ¼venlik**: Merkezi olmayan bir kimlik sistemi oluÅŸtururken, gÃ¼venli iletiÅŸim iÃ§in anahtar anlaÅŸmalarÄ± gereklidir.
    
2. **KullanÄ±cÄ± KontrolÃ¼**: KullanÄ±cÄ±lar kendi anahtarlarÄ±nÄ± oluÅŸturarak, kimliklerini ve verilerini kontrol edebilirler.
    
3. **Esneklik**: Bu fonksiyon, farklÄ± anahtar tÃ¼rlerini destekleyebilecek ÅŸekilde tasarlanmÄ±ÅŸtÄ±r, bu da onu farklÄ± uygulamalar iÃ§in uygun kÄ±lar.
    
4. **Entegrasyon**: Kilt ve Polkadot gibi mevcut blockchain teknolojileri ile uyumlu bir anahtar oluÅŸturma mekanizmasÄ± saÄŸlar.
:::

#### `generateKeypairs` Fonksiyonu

Daha Ã¶ncesinde oluÅŸturduÄŸumuz fonksiyonlar ile anahtar Ã§iftlerini oluÅŸutmak iÃ§in gerekli mekanizmayÄ± kurmuÅŸtuk. Åimdi de bu mekanizmadan anahtar Ã§iftlerini oluÅŸturmak iÃ§in gerekli fonksiyonu tanÄ±mlayabiliriz. Bu fonksiyon iÃ§erisine gireceÄŸimiz secret anahtarlar ile bizlere 4 adet anahtar Ã§ifti oluÅŸturacaktÄ±r.

```typescript title="attester/generateKeypairs.ts"
export function generateKeypairs(mnemonic = mnemonicGenerate()) {
```

Ä°lk olarak fonksiyonumuzu tanÄ±mlamak ile iÅŸe baÅŸlayabiliriz. Bu fonksiyon iÃ§erisine mnemonic bir ÅŸifre almaktadÄ±r. Ancak `mnemonicGenerate()` yapÄ±sÄ± kafa karÄ±ÅŸÄ±klÄ±ÄŸÄ± yaratabilir. Bu yapÄ± herhangi bir mnemonic ÅŸifre girdi verilmemesi durumunda sÄ±fÄ±rdan bir mnemonic ÅŸifre oluÅŸturmaktadÄ±r.

```typescript title="attester/generateKeypairs.ts"
const { account } = generateAccount(mnemonic);
```

Kodun iÃ§erisine girdiÄŸimizde ilk olarak `mnemonic` ÅŸifreden `generateAccount()` fonksiyonu sayesinde hesabÄ± oluÅŸtururuz. Bu hesabÄ± sonrasÄ±nda anahtar Ã§iftlerini Ã¼retmek iÃ§in kullanacaÄŸÄ±z.

:::tip Hadi Anahtar Ã‡iftlerini OluÅŸturmaya BaÅŸlayalÄ±m
ArtÄ±k 4 anahtar Ã§iftimizi oluÅŸturabiliriz.
:::

##### Kimlik DoÄŸrulama Anahtar Ã‡ifti (Authentication Keypair)

```typescript title="attester/generateKeypairs.ts"
const authentication = {
  ...account.derive('//did//0'),
  type: 'sr25519'
} as Kilt.KiltKeyringPair;
```

SatÄ±r satÄ±r ilerlenecek olunursa:
- `account.derive('//did//0')`: Hesaptan bir kimlik doÄŸrulama Ã§ifti tÃ¼retir.
- `type: 'sr25519'`: Anahtar Ã§iftinin tÃ¼rÃ¼nÃ¼ belirtir.
- `as Kilt.KiltKeyringPair`: Anahtar Ã§iftinin tÃ¼rÃ¼nÃ¼ Kilt'in anahtar Ã§ifti tÃ¼rÃ¼nde olduÄŸunu belirtir.

:::info Authentication Keypair HazÄ±r!
DoÄŸrulama yani Authentication anahtar Ã§iftimizi hazÄ±rladÄ±k. ArtÄ±k bu anahtar ile `claim`'ler hazÄ±rlayabilir ve doÄŸrulanmÄ±ÅŸ `credential`'leri sunabiliriz.
:::

##### Ä°ddia DoÄŸrulama Anahtar Ã‡ifti (Assertion KeyPair)

```typescript title="attester/generateKeypairs.ts"
const assertionMethod = {
  ...account.derive('//did//assertion//0'),
  type: 'sr25519'
} as Kilt.KiltKeyringPair;
```

Ãœst fonksiyonda da Ã¼rettiÄŸimiz Ã¼zere bu sefer de iddia beyanlarÄ±n doÄŸrulanmasÄ± iÃ§in hesaptan `sr25519` tÃ¼rÃ¼nde `Assertion` anahtar Ã§ifti Ã¼retilir.

##### Kabiliyet Delegasyonu Anahtar Ã‡ifti (Capability Delegation Keypair)

```typescript title="attester/generateKeypairs.ts"
const capabilityDelegation = {
  ...account.derive('//did//delegation//0'),
  type: 'sr25519'
} as Kilt.KiltKeyringPair;
```

SÄ±radaki deÄŸiÅŸkenimiz ile yeteneklerin veya izinlerin baÅŸka tarafa  devredilmesi iÃ§in anahtar Ã§ifti oluÅŸturulur. Bu anahtar Ã§ifti KILT zinciri iÃ§erisinde zincire `delegation`'larÄ±n yazÄ±mÄ± iÃ§in kullanÄ±lÄ±r.

##### AnlaÅŸma Anahtar Ã‡ifti (Key Agreement Keypair)

```typescript title="attester/generateKeypairs.ts"
const keyAgreement = generateKeyAgreement(mnemonic);
```

Son olarak `keyAgreement` anahtar Ã§ifti Ã¼retilmektedir. Bu anahtar mesajlarÄ± ÅŸifrelemek ve ÅŸifreleri kÄ±rmak iÃ§in kullanÄ±lÄ±r.

##### SonuÃ§larÄ± DÃ¶ndÃ¼rme

```typescript title="attester/generateKeypairs.ts"
return {
  authentication: authentication,
  keyAgreement: keyAgreement,
  assertionMethod: assertionMethod,
  capabilityDelegation: capabilityDelegation
};
```

Son olarak oluÅŸturduÄŸumuz anahtar Ã§iftlerini fonksiyon Ã§Ä±ktÄ±sÄ± olarak fonksiyon Ã§Ä±ktÄ±sÄ± olarak dÃ¶ndÃ¼rÃ¼rÃ¼z. 


:::danger Anahtar Ã‡ifti OluÅŸturma Fonksiyonumuz TamamlandÄ±!
Attester iÃ§in oluÅŸturacaÄŸÄ±mÄ±z DID'lerin 4 adet anahtar Ã§iftine ihtiyacÄ± bulunmaktaydÄ±. Bu anahtar Ã§iftlerini `generateKeypairs` fonksiyonu ile tÃ¼rettik. 
:::

:::info Kodun tamamÄ±nÄ± inceleyelim
YazdÄ±ÄŸÄ±mÄ±z kodu bÃ¼tÃ¼n olarak gÃ¶rmemiz gerekirse:
```typescript title="attester/generateKeypairs.ts"
import * as Kilt from '@kiltprotocol/sdk-js'
import {
  blake2AsU8a,
  keyExtractPath,
  keyFromPath,
  mnemonicGenerate,
  mnemonicToMiniSecret,
  sr25519PairFromSeed
} from '@polkadot/util-crypto'
import { generateAccount } from './generateAccount'

// Because there is no first-class support for this class of keys,
// we need to use a workaround to generate a key we can use for encryption/decryption.
function generateKeyAgreement(mnemonic: string) {
  const secretKeyPair = sr25519PairFromSeed(mnemonicToMiniSecret(mnemonic))
  const { path } = keyExtractPath('//did//keyAgreement//0')
  const { secretKey } = keyFromPath(secretKeyPair, path, 'sr25519')
  return Kilt.Utils.Crypto.makeEncryptionKeypairFromSeed(blake2AsU8a(secretKey))
}

export function generateKeypairs(mnemonic = mnemonicGenerate()) {
  const { account } = generateAccount(mnemonic)

  const authentication = {
    ...account.derive('//did//0'),
    type: 'sr25519'
  } as Kilt.KiltKeyringPair

  const assertionMethod = {
    ...account.derive('//did//assertion//0'),
    type: 'sr25519'
  } as Kilt.KiltKeyringPair

  const capabilityDelegation = {
    ...account.derive('//did//delegation//0'),
    type: 'sr25519'
  } as Kilt.KiltKeyringPair

  const keyAgreement = generateKeyAgreement(mnemonic)

  return {
    authentication: authentication,
    keyAgreement: keyAgreement,
    assertionMethod: assertionMethod,
    capabilityDelegation: capabilityDelegation
  }
}
```

SÄ±rasÄ±yla iÅŸleve bakÄ±lacak olunursa:
- Ä°lk olarak gerekli kÃ¼tÃ¼phaneleri tanÄ±mlarÄ±z. 
- SonrasÄ±nda mnemonic ÅŸifre iÃ§erisinden bazÄ± gizli anahtarlarÄ± Ã§Ä±karÄ±rÄ±z.
- Son olarak `generateKeypairs` fonksiyonu ile tÃ¼m anahtar Ã§iftlerini oluÅŸturup fonksiyon Ã§Ä±ktÄ±sÄ± olarak tanÄ±mlarÄ±z.
:::

DID oluÅŸturmak iÃ§in gerekli olan tÃ¼m anahtarlarÄ± topladÄ±ÄŸÄ±mÄ±za gÃ¶re zincir Ã¼zerindeki DID'lerimizi oluÅŸturmaya baÅŸlayabiliriz. 

### Anahtar Ã‡iftlerini Kullanarak DID OluÅŸturma

DID oluÅŸturmak iÃ§im ilk olarak tÃ¼m iÅŸlemleri baÅŸlatmamÄ±z gerekmektedir. SonrasÄ±nda bir Ã¶nceki kÄ±sÄ±mda (Attester Account) oluÅŸturduÄŸumuz hesabÄ± kodumuz iÃ§erisine Ã§ekebiliriz. Bu hesap DID kayÄ±t Ã¼cretlerini Ã¶demek iÃ§in oluÅŸturulmuÅŸ bir hesaptÄ±r. Son olarak DID kaydetmek iÃ§in gerekli transferi bildirebiliriz.

#### ModÃ¼llerin Ä°Ã§e AktarÄ±lmasÄ±

```typescript title="attester/generateDid.ts"
import { config as envConfig } from 'dotenv'
import * as Kilt from '@kiltprotocol/sdk-js'

import { generateAccount } from './generateAccount'
import { generateKeypairs } from './generateKeypairs'
```

Daha Ã¶nce de yaptÄ±ÄŸÄ±mÄ±z ÅŸekilde kÃ¼tÃ¼phaneleri kodumuz iÃ§erisine ekleriz. Buradaki yeni ve farklÄ± kÃ¼tÃ¼phanelere bakÄ±lacak olunursa: 

- `dotenv`: OluÅŸturdurÄŸumuz ortam deÄŸiÅŸkenlerini (ki bizim durumumuzda mnemonic ÅŸifre vb.) kodumuz iÃ§erisine yÃ¼klememizi saÄŸlamaktadÄ±r.
- `generateAccount` ve `generateKeypairs`: Ã–ncesinde attester klasÃ¶rÃ¼ iÃ§erisinde oluÅŸturduÄŸumuz kodlardan `export` edilen fonksiyonlarÄ± almamÄ±zÄ± saÄŸlar. 

#### `createFullDid` Fonksiyonu

```typescript title="attester/generateDid.ts"
export async function createFullDid(
  submitterAccount: Kilt.KiltKeyringPair
): Promise<{
  mnemonic: string
  fullDid: Kilt.DidDocument
}> {
```

Ä°lk olarak zincir Ã¼zerinde oluÅŸturacaÄŸÄ±mÄ±z DID'nin fonksiyonunu tanÄ±mlayarak iÅŸlemlere baÅŸlayabiliriz. Bu asenkron fonksiyon, bir `Kilt.KiltKeyringPair` tÃ¼rÃ¼nde `submitterAccount` alÄ±r ve bir `Promise` dÃ¶ndÃ¼rÃ¼r. Bu `Promise`, bir mnemonik ve bir `Kilt.DidDocument` iÃ§erir.

##### Kilt API BaÄŸlantÄ±sÄ± ve Mnemonik OluÅŸturma

```typescript title="attester/generateDid.ts"
const api = Kilt.ConfigService.get('api')
const mnemonic = Kilt.Utils.Crypto.mnemonicGenerate()
```

Fonksiyonun iÃ§erisine girildiÄŸinde sÄ±rasÄ±yla api'a baÄŸlanma ve `mnemonic` ÅŸifre oluÅŸturma iÅŸlemi karÅŸÄ±lamaktÄ±r. DID'lerin de kendine Ã¶zgÃ¼ `mnemonic` ÅŸifreleri bulunmaktadÄ±r. Bu ÅŸifre o yÃ¼zden bu kÄ±sÄ±mda oluÅŸturulmaktadÄ±r.

##### Anahtar Ã‡iftlerini OluÅŸturma

```typescript title="attester/generateDid.ts"
const {
  authentication,
  keyAgreement,
  assertionMethod,
  capabilityDelegation
} = generateKeypairs(mnemonic)
```

Bir Ã¶nceki yazdÄ±ÄŸÄ±mÄ±z kod dosyasÄ±nda DID'ler iÃ§in gerekli anahtar Ã§iftlerini oluÅŸturmamÄ±zÄ± saÄŸlayan `generateKeypairs` fonksiyonunu yazmÄ±ÅŸtÄ±k. Bu fonskiyon 4 anahtarÄ± Ã§Ä±ktÄ± vermekte olup iÃ§erisine `mnemonic` anahtarÄ± almaktaydÄ±. Bir Ã¶nceki satÄ±rda oluÅŸturduÄŸumuz `mnemonic` anahtarÄ± iÃ§erisine girerek 4 `generateKeypairs()` fonksiyonunu Ã§aÄŸÄ±rabiliriz. Bu iÅŸlem sonucunda 4 adet ÅŸifremizi deÄŸiÅŸkenlere sÄ±rasÄ±yla kaydedebiliriz.


##### DID OluÅŸturma Transferini GerÃ§ekleÅŸtirme

```typescript title="attester/generateDid.ts"
  const fullDidCreationTx = await Kilt.Did.getStoreTx(
    {
      authentication: [authentication],
      keyAgreement: [keyAgreement],
      assertionMethod: [assertionMethod],
      capabilityDelegation: [capabilityDelegation]
    },
    submitterAccount.address,
    async ({ data }) => ({
      signature: authentication.sign(data),
      keyType: authentication.type
    })
  )
```

DID'lerimizi oluÅŸturmak iÃ§in bir transfer iÅŸlemi yapmamÄ±z gerekmekte. Bu transfer iÅŸlemini `KILT SDK` iÃ§erisinde bulunan `getStoreTx()` fonksiyonu ile gerÃ§ekleÅŸtirebiliriz. Bu fonksiyonun aldÄ±ÄŸÄ± parametrelere bakÄ±lacak olunursa:

- Anahtar Ã‡iftleri: Ä°lk parametre olarak obje halinde 4 anahtarÄ± almaktadÄ±r.
- Hesap: Sonraki parametre bu hesabÄ±n hangi adrese ait olduÄŸunu ifade etmektedir.
- Ä°mza: Transferin gerÃ§ekleÅŸmesi iÃ§in gerekli olan imza iÅŸlemlerini gerÃ§ekleÅŸtirmektedir.

Bu ÅŸekilde gÃ¶ndereceÄŸimiz transferin bilgileri hazÄ±rlanmÄ±ÅŸ bir hale gelir.

##### Ä°ÅŸlemi GÃ¶nderme

```typescript title="attester/generateDid.ts"
await Kilt.Blockchain.signAndSubmitTx(fullDidCreationTx, submitterAccount)
```

Transferimizi hazÄ±rladÄ±ktan sonra `signAndSubmitTx` fonksiyonu ile iÅŸlemimizi onaylanmasÄ± iÃ§in gÃ¶nderebiliriz.

##### OluÅŸturduÄŸumuz DID'nin Bilgilerini Alma

```typescript title="attester/generateDid.ts"
const didUri = Kilt.Did.getFullDidUriFromKey(authentication)
const encodedFullDid = await api.call.did.query(Kilt.Did.toChain(didUri))
const { document } = Kilt.Did.linkedInfoFromChain(encodedFullDid)
```

DID'mizi oluÅŸturmak iÃ§in transferi gÃ¶nderdikten sonra artÄ±k bu transferin sonucunda oluÅŸturulan DID iÃ§in gerekli bilgileri deÄŸiÅŸkenlere kaydedebiliriz. Bu iÅŸlemler sÄ±rasÄ±yla:
- OluÅŸturulan DID iÃ§in bir URI oluÅŸturur.
- Bu URI'yi kullanarak DID dokÃ¼manÄ±nÄ± sorgular.

:::caution URI Nedir?
DID (Decentralized Identifier) sistemlerinde, URI (Uniform Resource Identifier) genellikle bir DID'nin benzersiz bir ÅŸekilde tanÄ±mlanmasÄ±nÄ± saÄŸlar. DID URI'leri, genellikle bir "scheme" (Ã¶rneÄŸin, `did:`), bir "method" (Ã¶rneÄŸin, `kilt:`) ve bir "method-specific identifier" (Ã¶rneÄŸin, bir blockchain adresi veya benzersiz bir kimlik) bÃ¶lÃ¼mlerinden oluÅŸur.

Ã–rneÄŸin, bir Kilt DID URI ÅŸu ÅŸekilde olabilir:

```
did:kilt:4uJ7uq1Nj4kZ4qHv3yzZRBuW9D2b3ZRF
```

Bu URI'nin parÃ§alarÄ± ÅŸunlardÄ±r:

- `did:`: Bu, URI'nin bir DID olduÄŸunu belirtir.
- `kilt:`: Bu, DID'nin Kilt metodunu kullandÄ±ÄŸÄ±nÄ± belirtir.
- `4uJ7uq1Nj4kZ4qHv3yzZRBuW9D2b3ZRF`: Bu, DID'nin benzersiz tanÄ±mlayÄ±cÄ±sÄ±dÄ±r, genellikle bir blockchain adresi veya baÅŸka bir benzersiz kimlik.

Bu URI, DID'nin nasÄ±l Ã§Ã¶zÃ¼leceÄŸini (yani, DID DokÃ¼manÄ±'nÄ±n nasÄ±l elde edileceÄŸini) ve DID'nin hangi blockchain veya merkezsiz aÄŸda saklandÄ±ÄŸÄ±nÄ± belirtir. Genellikle, bu URI'yi kullanarak, DID'nin sahip olduÄŸu anahtarlar, yetenekler ve diÄŸer Ã¶zellikler hakkÄ±nda bilgi alabilirsiniz.
:::

##### Hata KontrolÃ¼ ve DÃ¶nÃ¼ÅŸ DeÄŸeri

```typescript title="attester/generateDid.ts"
if (!document) {
  throw new Error('Full DID was not successfully created.')
}
return { mnemonic, fullDid: document }
```

Ä°ÅŸlemlerimize devam ettiÄŸimizde DID'nin baÅŸarÄ±lÄ± bir ÅŸekilde oluÅŸup oluÅŸmadÄ±ÄŸÄ±nÄ± kontrol eden bir mekanizma bizleri karÅŸÄ±lamaktadÄ±r. DID dÃ¼zgÃ¼n bir ÅŸekilde oluÅŸturulmuÅŸsa `return` ifadesi ile bu URI dÃ¶ndÃ¼rÃ¼lmektedir.

#### Ana Program

Åimdi de ana program Ã§alÄ±ÅŸtÄ±ÄŸÄ±nda neler yapmamÄ±z gerektiÄŸini belirten fonksiyonu yazabiliriz. 

```typescript title="attester/generateDid.ts"
if (require.main === module) {
  ;(async () => {
  envConfig()
```

Fonksiyon tanÄ±mlanÄ±p `envConfig()` fonksiyonu ile`.env` dosyasÄ±ndaki iÃ§erikler alÄ±nÄ±r. 

:::tip
YazdÄ±ÄŸÄ±mÄ±z kod dosyasÄ± hem farklÄ± kod dosyalarÄ± tarafÄ±ndan Ã§aÄŸÄ±rÄ±larak hemde kendi baÅŸlarÄ±na Ã§alÄ±ÅŸtÄ±rÄ±labilir. FarklÄ± dosyalar tarafÄ±ndan Ã§alÄ±ÅŸtÄ±rÄ±lÄ±cakken `export` yapÄ±sÄ±na sahip fonksiyonlar kullanÄ±labilecek olunurken kendi baÅŸlarÄ±na Ã§alÄ±ÅŸtÄ±rÄ±lacakken `require.main` yapÄ±sÄ±na ihtiyaÃ§ duyarlar.  
:::

```typescript title="attester/generateDid.ts"
try {

	.
	.
	.
	
} catch (e)
	console.log("Error while creating attester DID")
	trow e
}	
```

FonksiyonlarÄ± Ã§aÄŸÄ±rmak iÃ§in bir `try` `catch` yapÄ±sÄ± kurarÄ±z. Bu sayede `try` yapÄ±sÄ± iÃ§erisine yazacaÄŸÄ±mÄ±z kodlar Ã§alÄ±ÅŸmazsa `catch` ifadesi hatayÄ± yakalar ve bizlere sÃ¶yler.

Åimdi `try` yapÄ±sÄ± iÃ§erisine girebiliriz.

```typescript title="attester/generateDid.ts"
const accountMnemonic = process.env.ATTESTER_ACCOUNT_MNEMONIC as string
```

Ä°lk olarak `.env` dosyasÄ±ndan daha Ã¶ncesinde oluÅŸturmuÅŸ olduÄŸumuz `attester mnemonic` anahtarÄ±mÄ±zÄ± kodumuza ekleriz. 

```typescript title="attester/generateDid.ts"
const { account } = generateAccount(accountMnemonic)

const { mnemonic, fullDid } = await createFullDid(account)
```

Daha sonrasÄ±nda ekleÄŸimiz bu `mnemonic`anahtardan daha Ã¶nceden sÄ±rasÄ±yla tanÄ±mladÄ±ÄŸÄ±mÄ±z `generateAccount` ve `createFullDid` methodlarÄ± ile `account` ve bu account deÄŸerinden `fullDid` deÄŸerini elde ederiz. 

```typescript title="attester/generateDid.ts"
console.log('\nsave following to .env to continue\n');
console.error(`ATTESTER_DID_MNEMONIC="${mnemonic}"\n`);
console.error(`ATTESTER_DID_URI="${fullDid.uri}"\n`);
```

Daha sonrasÄ±nda son olarak bu bilgileri kullanÄ±cÄ±ya vererek iÅŸlemleri tamamlarÄ±z. Kodumuz bu ÅŸekilde tamamlanmÄ±ÅŸ olur.

:::info Genel Bir bakÄ±ÅŸ yapalÄ±m
Kodumuzu yazdÄ±k ancak genel bir bakÄ±ÅŸ yapmamÄ±z gerekirse `generateDid.ts`  dosyasÄ±nÄ±n iÃ§erisindeki tÃ¼m kodlar ÅŸu ÅŸekilde olacaktÄ±r:

```typescript title="attester/generateDid.ts"
import { config as envConfig } from 'dotenv'

import * as Kilt from '@kiltprotocol/sdk-js'

import { generateAccount } from './generateAccount'
import { generateKeypairs } from './generateKeypairs'

export async function createFullDid(
  submitterAccount: Kilt.KiltKeyringPair
): Promise<{
  mnemonic: string
  fullDid: Kilt.DidDocument
}> {
  const api = Kilt.ConfigService.get('api')

  const mnemonic = Kilt.Utils.Crypto.mnemonicGenerate()
  const {
    authentication,
    keyAgreement,
    assertionMethod,
    capabilityDelegation
  } = generateKeypairs(mnemonic)
  // Get tx that will create the DID on chain and DID-URI that can be used to resolve the DID Document.
  const fullDidCreationTx = await Kilt.Did.getStoreTx(
    {
      authentication: [authentication],
      keyAgreement: [keyAgreement],
      assertionMethod: [assertionMethod],
      capabilityDelegation: [capabilityDelegation]
    },
    submitterAccount.address,
    async ({ data }) => ({
      signature: authentication.sign(data),
      keyType: authentication.type
    })
  )

  await Kilt.Blockchain.signAndSubmitTx(fullDidCreationTx, submitterAccount)

  const didUri = Kilt.Did.getFullDidUriFromKey(authentication)
  const encodedFullDid = await api.call.did.query(Kilt.Did.toChain(didUri))
  const { document } = Kilt.Did.linkedInfoFromChain(encodedFullDid)

  if (!document) {
    throw new Error('Full DID was not successfully created.')
  }

  return { mnemonic, fullDid: document }
}

// Don't execute if this is imported by another file.
if (require.main === module) {
  ;(async () => {
    envConfig()

    try {
      await Kilt.connect(process.env.WSS_ADDRESS as string)

      // Load attester account
      const accountMnemonic = process.env.ATTESTER_ACCOUNT_MNEMONIC as string
      const { account } = generateAccount(accountMnemonic)
      const { mnemonic, fullDid } = await createFullDid(account)

      console.log('\nsave following to .env to continue\n')
      console.error(`ATTESTER_DID_MNEMONIC="${mnemonic}"\n`)
      console.error(`ATTESTER_DID_URI="${fullDid.uri}"\n`)
    } catch (e) {
      console.log('Error while creating attester DID')
      throw e
    }
  })()
}
```

Bu kodun neler yaptÄ±ÄŸÄ±na genel olarak bakÄ±cak olursak:

- Paketleri ve daha Ã¶nce yazdÄ±ÄŸÄ±mÄ±z kodlarÄ± dosyaya entegre ediyoruz.
- `createFullDid()` fonksiyonunu tanÄ±mlayÄ±p bu fonksiyon ile `generateKeypairs.ts` kod dosyasÄ±ndaki `generateKeypairs()` fonksiyonunu Ã§aÄŸÄ±rÄ±p anahtar Ã§iftlerimizi oluÅŸturuyoruz.
- Anahtar Ã§iftlerimiz ile DID'mizin transferini zincire yazÄ±p onaylÄ±yoruz.
- Transfer sonrasÄ±nda `DID mnemonic anahtarÄ±nÄ±` ve `uri` deÄŸerini oluÅŸturuyoruz.
- Kod dosyasÄ±nÄ± Ã§alÄ±ÅŸtÄ±rÄ±p `.env` dosyasÄ± iÃ§erisinde yazdÄ±ÄŸÄ±mÄ±z `attester mnemonic` anahtarÄ± iÃ§in `createFullDid()` fonskiyonunu Ã§aÄŸÄ±rÄ±p sonuÃ§larÄ± ekrana yazdÄ±rÄ±yoruz.
::: 

### Kodu Ã‡alÄ±ÅŸtÄ±rmak

Kodumuzu Ã§alÄ±ÅŸtÄ±rmak iÃ§in terminalde `kilt-rocks` konumunda olduÄŸumuza emin olduktan sonra alt kÄ±sÄ±mdaki kodu Ã§alÄ±ÅŸtÄ±rabiliriz.

```terminal
yarn ts-node ./attester/generateDid.ts
```

:::caution Hata mÄ± aldÄ±n?
Kod Ã§alÄ±ÅŸÄ±rken birÃ§ok yerden hata almÄ±ÅŸ olabilirsin ancak Ã§okÃ§a karÅŸÄ±laÅŸÄ±lan hata kullanÄ±cÄ±nÄ±n `attester` hesabÄ±na `PILT` coinlerini faucet'den almamasÄ±dÄ±r. HesabÄ±nda yeterli miktarÄ±n olduÄŸuna emin ol ve o ÅŸekilde devam et!
:::

### SonuÃ§larÄ± AlalÄ±m!

Kodumuz Ã§alÄ±ÅŸtÄ±ÄŸÄ±nda bizlere DID'miz iÃ§in yeni bir `mnemonic` ÅŸifre ve `uri` deÄŸerinin oluÅŸtuÄŸunu gÃ¶rebiliriz. 

:::danger SakÄ±n Unutma
Kodumuzu Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±mÄ±zda ortaya Ã§Ä±kan Mnemonic ve URI deÄŸerlerini `.env` dosyasÄ± iÃ§erisine kaydetmemiz gerekiyor!
:::