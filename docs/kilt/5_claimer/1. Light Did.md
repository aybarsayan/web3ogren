# Claimer Light DID ğŸŒŸ

ArtÄ±k `Claimer` iÃ§in light DID oluÅŸturmaya baÅŸlayabiliriz. ğŸš€

:::caution ğŸ¤” Bir de Light DID mi Ã§Ä±ktÄ± o ne? 
Light DID, zincir Ã¼zerinde tutulmayan DID'lere denilmektedir. Zincir Ã¼zerinde tutulmadÄ±ÄŸÄ± iÃ§in oluÅŸtururken ekstra iÅŸlem Ã¼cretine gerek duymamaktadÄ±r. ğŸ‰

Light DID'ler ÅŸunlarÄ± yapabilir:

- DoÄŸrulama isteklerini ve sunumunu kimlik doÄŸrulama anahtarlarÄ±yla imzalayabilir. ğŸ–‹ï¸
- Encryption anahtarÄ± ile mesajlarÄ± ÅŸifreleyebilir. ğŸ”’ 
:::

![alternative text](../../../static/img/kilt/lightfull.jpeg "Genel BakÄ±ÅŸ")

## Gerekli AnahtarlarÄ± OluÅŸturma ğŸ”‘

`Attester`'da olduÄŸu gibi Claimer'Ä±n da DID anahtarlarÄ± oluÅŸturmasÄ± gerekmektedir. ğŸ› ï¸

### Paketlerin Eklenmesi ğŸ“¦

```typescript title="claimer/generateKeypairs.ts"
import * as Kilt from '@kiltprotocol/sdk-js'
import {
  blake2AsU8a,
  keyExtractPath,
  keyFromPath,
  mnemonicGenerate,
  mnemonicToMiniSecret,
  sr25519PairFromSeed
} from '@polkadot/util-crypto'
import { generateAccount } from '../attester/generateAccount'
```

Ä°lk olarak importlarÄ±mÄ±zÄ± yaparak iÅŸe baÅŸlÄ±yoruz. ğŸŒˆ Bu importlarÄ± `Attester DID`'lerini oluÅŸtururken de ayrÄ±ntÄ±lÄ± gÃ¶rmÃ¼ÅŸtÃ¼k, ancak burada da kÄ±saca bahsetmek gerekirse:

- KILT SDK'yÄ± ve Polkadot'un kripto yardÄ±mcÄ± fonksiyonlarÄ±nÄ± import ediyoruz. ğŸ“š
- SonrasÄ±nda `generateAccount` fonksiyonunu da import ediyoruz. ğŸ—‚ï¸

:::danger ğŸš¨ generateAccount 

HesabÄ± oluÅŸturmak iÃ§in gerekli iÅŸlemler her birey iÃ§in aynÄ± olduÄŸundan dolayÄ± `generateAccount()` fonksiyonuna `attester` klasÃ¶rÃ¼nden eriÅŸerek bir kez daha kodu yazma zorunluluÄŸundan kurtulabiliriz. ğŸ‰ 
:::

### `generateKeyAgreement` Fonksiyonu

```typescript title="claimer/generateKeypairs.ts"
function generateKeyAgreement(mnemonic: string) {
  const secretKeyPair = sr25519PairFromSeed(mnemonicToMiniSecret(mnemonic))
  const { path } = keyExtractPath('//did//keyAgreement//0')
  const { secretKey } = keyFromPath(secretKeyPair, path, 'sr25519')
  return Kilt.Utils.Crypto.makeEncryptionKeypairFromSeed(blake2AsU8a(secretKey))
}
```

:::tip ğŸ“ TanÄ±dÄ±k geldi mi? 
Bu fonksiyon `attester`'Ä±n DID'sini oluÅŸtururken yazdÄ±ÄŸÄ±mÄ±z `generateKeyAgreement()` fonksiyonunun aynÄ±sÄ± olmaktadÄ±r. O kÄ±sÄ±mda anladÄ±ysanÄ±z alt kÄ±smÄ± atlayÄ±p bir sonraki fonksiyona gidebilirsiniz. ğŸƒâ€â™€ï¸ 
:::

Attester'da da benzerini oluÅŸturduÄŸumuz gibi ilk olarak anahtar Ã§iftlerini oluÅŸturmak iÃ§in bu Ã§iftlerin argÃ¼manlarÄ±nÄ± oluÅŸturmamÄ±z gerekir. Bu iÅŸlem iÃ§in `generateKeyAgreement()` fonsksiyonunu kullanacaÄŸÄ±z. Bu fonksiyon iÃ§erisine `string` formatÄ±nda `mnemonic` anahtarÄ± alacaktÄ±r. Ã‡Ä±ktÄ± olarak anahtar argÃ¼manlarÄ±nÄ± ifade edecektir. SÄ±rasÄ±yla iÃ§eriÄŸine bakÄ±lacak olunursa:

- `sr25519PairFromSeed` ve `mnemonicToMiniSecret` fonksiyonlarÄ± ile gizli bir anahtar Ã§ifti oluÅŸturulur.
- `keyExtractPath` ve `keyFromPath` fonksiyonlarÄ± ile anahtarÄ±n yolu ve gizli anahtar Ã§Ä±karÄ±lÄ±r.
- Son olarak, `Kilt.Utils.Crypto.makeEncryptionKeypairFromSeed` fonksiyonu ile ÅŸifreleme anahtar Ã§ifti oluÅŸturulur.

### `generateKeypairs` Fonksiyonu

```typescript title="claimer/generateKeypairs.ts"
export function generateKeypairs(mnemonic = mnemonicGenerate()) {
  const { account } = generateAccount(mnemonic)
  const authentication = {
    ...account.derive('//did//0'),
    type: 'sr25519'
  } as Kilt.KiltKeyringPair
  const keyAgreement = generateKeyAgreement(mnemonic)
  return {
    authentication: authentication,
    keyAgreement: keyAgreement
  }
}
```

Anahtar argÃ¼manlarÄ± Ã¼rettikten sonra bu argÃ¼manlar ile anahtar Ã§iftlerini oluÅŸturabiliriz. Bu iÅŸlem iÃ§in `generateKeypairs()` fonksiyonu kullanÄ±lacaktÄ±r. Fonksiyonun iÅŸlevine bakÄ±lacak olunursa:

- Ä°lk olarak Bu fonksiyon, bir mnemonik alÄ±r (eÄŸer verilmezse, yeni bir mnemonik oluÅŸturur) ve kimlik doÄŸrulama ve anahtar anlaÅŸmasÄ± anahtar Ã§iftlerini oluÅŸturur.
- `generateAccount()` fonksiyonu kullanÄ±larak `mnemonic` ÅŸifreden hesap oluÅŸturulur.
- `account.derive` ile kimlik doÄŸrulama anahtarÄ± oluÅŸturulur.
	- `account.derive('//did//0')`: Hesaptan bir kimlik doÄŸrulama Ã§ifti tÃ¼retir.
	- `type: 'sr25519'`: Anahtar Ã§iftinin tÃ¼rÃ¼nÃ¼ belirtir.
	- `as Kilt.KiltKeyringPair`: Anahtar Ã§iftinin tÃ¼rÃ¼nÃ¼ Kilt'in anahtar Ã§ifti tÃ¼rÃ¼nde olduÄŸunu belirtir.
- `generateKeyAgreement` fonksiyonu ile anahtar anlaÅŸmasÄ± anahtarÄ± oluÅŸturulur.
- Son olarak bu oluÅŸturulan anahtarlar `return` kullanÄ±larak Ã§Ä±ktÄ± edilir.

:::caution BirkaÃ§ FarklÄ±lÄ±k Var
Benzer iÅŸlemleri Attester iÃ§in de yapmÄ±ÅŸ olsak da birkaÃ§ farklÄ±lÄ±k fark etmiÅŸ olabilirsiniz. Bu farklÄ±lÄ±klardan ilki `attester` iÃ§in oluÅŸturduÄŸumuz DID'de 4 adet anahtar kullanmÄ±ÅŸken `claimer` iÃ§in 2 adet oluÅŸturmuÅŸ olmamÄ±zdÄ±r.  Zincir Ã¼zerinde tutulmayacak ve imzalama iÅŸlemleri yapmayacaÄŸÄ±ndan dolayÄ± `claimer` iÃ§in bu 2 anahtar yeterlidir.
:::

:::info Kodun TamamÄ±
Anahtar argÃ¼manlarÄ±nÄ± oluÅŸturmak iÃ§in gerekli kodu yazdÄ±k. Bu kodu ÅŸu ÅŸekilde tamamÄ±yla gÃ¶rÃ¼ntÃ¼leyebiliriz.
```typescript title="claimer/generateKeypairs.ts"
import * as Kilt from '@kiltprotocol/sdk-js'
import {
  blake2AsU8a,
  keyExtractPath,
  keyFromPath,
  mnemonicGenerate,
  mnemonicToMiniSecret,
  sr25519PairFromSeed
} from '@polkadot/util-crypto'
import { generateAccount } from './generateAccount'

function generateKeyAgreement(mnemonic: string) {
  const secretKeyPair = sr25519PairFromSeed(mnemonicToMiniSecret(mnemonic))
  const { path } = keyExtractPath('//did//keyAgreement//0')
  const { secretKey } = keyFromPath(secretKeyPair, path, 'sr25519')
  return Kilt.Utils.Crypto.makeEncryptionKeypairFromSeed(blake2AsU8a(secretKey))
}

export function generateKeypairs(mnemonic = mnemonicGenerate()) {
  const { account } = generateAccount(mnemonic)

  const authentication = {
    ...account.derive('//did//0'),
    type: 'sr25519'
  } as Kilt.KiltKeyringPair

  const keyAgreement = generateKeyAgreement(mnemonic)

  return {
    authentication: authentication,
    keyAgreement: keyAgreement
  }
}
```

:::

:::info
Claimer  `authentication key` (doÄŸrulama anahtarÄ±) ve `encryption key` (ÅŸifreleme anahtarÄ±) deÄŸerlerine sahip olmalÄ±dÄ±r. Bu anahtarlar aynÄ± mnemonic ÅŸifre kullanÄ±larak Ã¼retilebilse de farklÄ± mnemonic ÅŸifreler de kullanÄ±labilir.
:::

## Light DID OluÅŸturma

`keypair` deÄŸerlerini oluÅŸturduktan sonra `light DID`'leri Ã¼retebiliriz. Zincir Ã¼zerinde depolanmadÄ±ÄŸÄ± iÃ§in her seferinde yeni bir DID objesi oluÅŸturabiliriz, her seferinde kaydetmemize gerek bulunmamakta. Ancak yine de `mneminic` ÅŸifreyi `.env` dosyasÄ± Ã¼zerinde kaydedeceÄŸiz.

![alternative text](../../../static/img/kilt/light%20DID.gif "Genel BakÄ±ÅŸ")

### Paket Ekleme

```typescript title="claimer/generateLightDid.ts"
import { config as envConfig } from 'dotenv'
import { mnemonicGenerate } from '@polkadot/util-crypto'
import * as Kilt from '@kiltprotocol/sdk-js'
import { generateKeypairs } from './generateKeypairs'
```

Paketlerimizi `generateLightDid.ts` dosyasÄ± iÃ§erisine import ediyoruz bu paketlere ek olarak `generateKeypairs` yapÄ±sÄ±nÄ±n olduÄŸunu gÃ¶rÃ¼ntÃ¼leyebiliriz. Bu yapÄ± bir Ã¶nceki dosyada `export` ederek yazdÄ±ÄŸÄ±mÄ±z `generateKeypairs()` fonksiyonuna eriÅŸmemizi saÄŸlar.

### `generateLightDid` Fonksiyonu

```typescript title="claimer/generateLightDid.ts"
export function generateLightDid(mnemonic: string): Kilt.DidDocument {
  const { authentication, keyAgreement } = generateKeypairs(mnemonic)
  return Kilt.Did.createLightDidDocument({
    authentication: [authentication as Kilt.NewLightDidVerificationKey],
    keyAgreement: [keyAgreement]
  })
}
```

ArtÄ±k `Claimer` bireyi iÃ§in oluÅŸturacaÄŸÄ±mÄ±z DID'nin oluÅŸacaÄŸÄ± fonksiyonu yazabiliriz. Bu fonksiyon iÃ§erisine `mnemonic` anahtarÄ± alacak olup Ã§Ä±ktÄ± olarak `Claimer DID` deÄŸerini verecektir. SatÄ±r satÄ±r kodun yaptÄ±klarÄ±na bakÄ±lacak olunursa:

- Ä°lk olarak `authentication` ve `keyAgreement` deÄŸiÅŸkenleri oluÅŸturulup bir Ã¶nceki kod dosyasÄ±nda yazdÄ±ÄŸÄ±mÄ±z `generateKeypairs()` fonksiyonu iÃ§erisine `mnemonic` ÅŸifreyi alarak Ã§alÄ±ÅŸÄ±r.
- DevamÄ±nda bu deÄŸiÅŸkenler `Kilt.Did.createLightDidDocument()` methoduna girdi olarak verilerek `Light DID` oluÅŸturulur ve Ã§Ä±ktÄ± verilir. 

### Ana Kod BloÄŸu

```typescript title="claimer/generateLightDid.ts"
if (require.main === module) {
  ;(async () => {
    envConfig()
    try {
      await Kilt.init()
      const mnemonic = mnemonicGenerate()
      console.log('\nsave following to .env to continue\n')
      console.log(`CLAIMER_DID_MNEMONIC="${mnemonic}"`)
    } catch (e) {
      console.log('Error while setting up claimer DID')
      throw e
    }
  })()
}
```

Bu kod bloÄŸu `generateLightDid.ts` dosyasÄ± doÄŸrudan Ã§alÄ±ÅŸtÄ±rÄ±lÄ±rsa Ã§alÄ±ÅŸacak fonksiyondur. Fonksiyonun iÃ§erisine girildiÄŸinde ilk olarak `envConfig` fonksiyonu ile `.env` dosyasÄ±ndaki bilgiler eriÅŸilir. DevamÄ±nda `try` `catch` yapÄ±sÄ±na girilir. Bu yapÄ±da izlenen iÅŸlemlere bakÄ±lacak olunursa:
- `Kilt.init()` ile KILT SDK baÅŸlatÄ±lÄ±r.
- Yeni bir mnemonik oluÅŸturulur ve konsola yazdÄ±rÄ±lÄ±r. Bu mnemonik `.env` dosyasÄ±na kaydedilmelidir.
- EÄŸer bir hata oluÅŸursa, hata mesajÄ± konsola yazdÄ±rÄ±lÄ±r ve hata fÄ±rlatÄ±lÄ±r.

---

TÃ¼m iÅŸlemler tamamladÄ±ktan sonra Light DID iÃ§in kullanÄ±lacak mnemonic anahtarÄ± Ã¼retmiÅŸ oluruz. Fark etmiÅŸ olabileceÄŸiniz gibi `Claimer`'Ä±n herhangi bir hesap adresi veya hesabÄ± yoktur. Bu durumun nedeni `Claimer`'Ä±n herhangi bir bakiye tutmak zorunda olmamasÄ± ve zincirde hesap oluÅŸturma zorunluluÄŸunun olmamasÄ±dÄ±r.

:::tip GÃ¼zel Ã–zellik AslÄ±nda
`Claimer` bireyinin zincir iÃ§erisinde hesap oluÅŸturma zorunluluÄŸunun olmamasÄ± bizlere birÃ§ok alanda kolaylÄ±k saÄŸlamaktadÄ±r. Ã–rneÄŸin `Claimer` bireyi herhangi biri olabileceÄŸi iÃ§in blokzinciri bile bilmeyen bir kullanÄ±cÄ± hesap aÃ§madan veya ne ile karÅŸÄ± karÅŸÄ±ya kaldÄ±ÄŸÄ±nÄ± anlamasÄ±na gerek kalmadan arayÃ¼zden bu iÅŸlemleri gerÃ§ekleÅŸtirebilir.
:::

:::info Genel Ä°ÅŸleyiÅŸ
YazdÄ±ÄŸÄ±mÄ±z `generateLightDid.ts` kodunun tamamÄ±na bakarak yaptÄ±ÄŸÄ±mÄ±z iÅŸlemleri daha iyi anlamamÄ±z gerekirse:

```typescript title="claimer/generateLightDid.ts"
import { config as envConfig } from 'dotenv'

import { mnemonicGenerate } from '@polkadot/util-crypto'

import * as Kilt from '@kiltprotocol/sdk-js'

import { generateKeypairs } from './generateKeypairs'

export function generateLightDid(mnemonic: string): Kilt.DidDocument {
  const { authentication, keyAgreement } = generateKeypairs(mnemonic)
  return Kilt.Did.createLightDidDocument({
    authentication: [authentication as Kilt.NewLightDidVerificationKey],
    keyAgreement: [keyAgreement]
  })
}

// Don't execute if this is imported by another file.
if (require.main === module) {
  ;(async () => {
    envConfig()

    try {
      await Kilt.init()

      const mnemonic = mnemonicGenerate()
      console.log('\nsave following to .env to continue\n')
      console.log(`CLAIMER_DID_MNEMONIC="${mnemonic}"`)
    } catch (e) {
      console.log('Error while setting up claimer DID')
      throw e
    }
  })()
}
```

- Paketlerimizi ve generateKeypairs.ts dosyasÄ±nÄ± dosyamÄ±z iÃ§erisine ekledik.
- Anahtar argÃ¼manlarÄ± Ã§aÄŸÄ±rarak Light DID oluÅŸturma fonksiyonunu oluÅŸturduk.
- Kodun tek baÅŸÄ±na Ã§alÄ±ÅŸtÄ±rÄ±lma olasÄ±lÄ±ÄŸÄ±na karÅŸÄ±n `generateLightDid()` fonksiyonunu Ã§alÄ±ÅŸtÄ±racak ve Light DID'e ait `mnemonic` ÅŸifreyi ekrana yazacak bir fonksiyon yapÄ±sÄ± kurduk. 
:::


## Kodu Ã‡alÄ±ÅŸtÄ±rma

YazdÄ±ÄŸÄ±mÄ±z birbirine baÄŸlÄ± 2 kodu Ã§alÄ±ÅŸtÄ±rmak iÃ§in `kilt-rocks` klasÃ¶rÃ¼nde olduÄŸumuza emin olduktan sonra alt kÄ±sÄ±mdaki kodu Ã§alÄ±ÅŸtÄ±rabiliriz.

```terminal
yarn ts-node ./claimer/generateLightDid.ts
```

:::danger SakÄ±n Unutma!
Kodu Ã§alÄ±ÅŸtÄ±rdÄ±ktan sonra bizlere bir `CLAIMER_DID_MNEMONIC` deÄŸeri verilecektir. bu deÄŸeri kesinlikle `.env` dosyamÄ±za kaydetmemiz gerekir.

![alternative text](../../../static/img/kilt/look%20at%20me.gif "Genel BakÄ±ÅŸ")

:::

:::tip
HarikasÄ±n beee Light DID de oluÅŸturdun
:::